#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#define CLEAR "cls"
#define LOG_FILE "action_log.txt"
#else
#include <unistd.h>
#define CLEAR "clear"
#define LOG_FILE "action_log.txt"
#endif

// ⚠️ RESPONSIBLE USAGE NOTICE:
// This tool is for educational purposes and personal security testing only.
// Unauthorized use on systems you do not own may violate the law.
// The author is NOT responsible for any misuse of this script.

// Function to log actions to a file
void logAction(const char *message) {
    FILE *log = fopen(LOG_FILE, "a+");
    if (log != NULL) {
        fprintf(log, "%s\n", message);
        fclose(log);
    }
}

// Function to check if running as Administrator (Windows) or Root (Linux)
int isAdmin() {
#ifdef _WIN32
    BOOL isAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;
    
    if (AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, 
                                 DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup)) {
        CheckTokenMembership(NULL, AdministratorsGroup, &isAdmin);
        FreeSid(AdministratorsGroup);
    }
    return isAdmin;
#else
    return (geteuid() == 0);  // Check if UID is 0 (root)
#endif
}

// Function to lock a directory securely
void lockDirectory(const char *path) {
    char command[1024];

#ifdef _WIN32
    snprintf(command, sizeof(command), "icacls \"%s\" /inheritance:d /grant:r Everyone:(RX)", path);
#else
    snprintf(command, sizeof(command), "chmod 500 \"%s\"", path);
#endif

    int status = system(command);
    if (status != 0) {
        printf("[!] Failed to lock %s. Error code: %d\n", path, status);
        logAction("[!] Lock failed");
    } else {
        printf("[+] Successfully locked %s\n", path);
        logAction("[+] Path locked successfully");
    }
}

// Function to unlock a directory securely
void unlockDirectory(const char *path) {
    char command[1024];

#ifdef _WIN32
    snprintf(command, sizeof(command), "icacls \"%s\" /reset", path);
#else
    snprintf(command, sizeof(command), "chmod 755 \"%s\"", path);
#endif

    int status = system(command);
    if (status != 0) {
        printf("[!] Failed to unlock %s. Error code: %d\n", path, status);
        logAction("[!] Unlock failed");
    } else {
        printf("[+] Successfully unlocked %s\n", path);
        logAction("[+] Path unlocked successfully");
    }
}

// Function to validate paths and prevent unsafe operations
int isPathValid(const char *path) {
    char username[256];

#ifdef _WIN32
    DWORD size = sizeof(username);
    GetUserName(username, &size);
#else
    snprintf(username, sizeof(username), "%s", getenv("USER"));
#endif

    // Prevent locking critical system paths
#ifdef _WIN32
    if (strstr(path, "C:\\Windows\\System32") != NULL || strstr(path, "C:\\Program Files") != NULL) {
        printf("[!] Cannot modify critical system paths. Operation aborted.\n");
        logAction("[!] Attempt to modify system path blocked");
        return 0;
    }
#else
    if (strcmp(path, "/") == 0 || strstr(path, "/root") != NULL || strstr(path, "/etc") != NULL) {
        printf("[!] Cannot modify critical system paths. Operation aborted.\n");
        logAction("[!] Attempt to modify system path blocked");
        return 0;
    }
#endif

    // Prevent use by unauthorized users
    if (strcmp(username, "root") == 0 || isAdmin()) {
        printf("[!] Running as root/admin is restricted. Use a normal user account.\n");
        logAction("[!] Unauthorized admin/root access attempt");
        return 0;
    }

    return 1;
}

int main() {
    char path[512];
    int choice;
    char consent[4];

    // Clear console for better readability
    system(CLEAR);

    // Display warning
    printf("⚠️ RESPONSIBLE USE NOTICE:\n");
    printf("This tool is for personal security and educational purposes ONLY.\n");
    printf("Unauthorized use may violate local laws and terms of service.\n");
    printf("The author takes NO responsibility for misuse.\n\n");

    // Get absolute path
    printf("[?] Enter the absolute path to lock or unlock: ");
    fgets(path, sizeof(path), stdin);
    path[strcspn(path, "\n")] = 0;

    // Validate path
    if (strlen(path) < 3 || !isPathValid(path)) {
        printf("[!] Invalid path. Aborting.\n");
        logAction("[!] Invalid path detected");
        return 1;
    }

    // Select lock or unlock operation
    printf("\n[1] Lock Path\n[2] Unlock Path\n[?] Choose an option: ");
    if (scanf("%d", &choice) != 1) {
        printf("[!] Invalid input. Aborting.\n");
        logAction("[!] Invalid menu choice");
        return 1;
    }

    // Require explicit consent
    printf("⚠️ Are you sure you want to proceed? Type 'YES' to continue: ");
    scanf("%s", consent);
    if (strcmp(consent, "YES") != 0) {
        printf("[!] Operation cancelled by user.\n");
        logAction("[!] User cancelled operation");
        return 1;
    }

    if (choice == 1) {
        lockDirectory(path);
    } else if (choice == 2) {
        unlockDirectory(path);
    } else {
        printf("[!] Invalid choice. Aborting.\n");
        logAction("[!] Invalid menu choice");
    }

    return 0;
}
