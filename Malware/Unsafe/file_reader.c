#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdint.h>
#include <openssl/md5.h>

#define BUFFER_SIZE 1024
#define LOG_FILE "forensic_log.txt"

// ‚ö†Ô∏è LEGAL DISCLAIMER:
// This tool is for forensic analysis, cybersecurity research, and **authorized** use only.
// Running this tool without **explicit written consent** from the system owner is ILLEGAL.
// Unauthorized monitoring, scanning, or use may violate privacy and computer misuse laws.
//
// ‚úîÔ∏è Only use this tool in environments where you have received **written** permission.
// ‚úîÔ∏è The author is NOT responsible for any **misuse, data loss, or legal consequences**.
//
// üö® **STOP** if you are unsure about the legality of running this program. üö®

// Function to log actions to a file for accountability
void logAction(const char *message) {
    FILE *log = fopen(LOG_FILE, "a+");
    if (log != NULL) {
        fprintf(log, "%s\n", message);
        fclose(log);
    }
}

// Function to check if the user has administrative privileges
int isAdmin() {
    BOOL isAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;
    
    if (AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, 
                                 DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup)) {
        CheckTokenMembership(NULL, AdministratorsGroup, &isAdmin);
        FreeSid(AdministratorsGroup);
    }
    return isAdmin;
}

// Function to validate paths and prevent scanning system directories
int isPathValid(const char *path) {
    if (strstr(path, "C:\\Windows") || strstr(path, "C:\\Program Files") || strstr(path, "C:\\System32")) {
        printf("[!] Access to system directories is restricted. Operation aborted.\n");
        logAction("[!] Attempted access to restricted system path.");
        return 0;
    }
    return 1;
}

// Function to calculate the MD5 hash of a file
void calculate_md5(const char *filename, unsigned char *result) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        printf("[!] Error opening file: %s\n", filename);
        logAction("[!] File access error.");
        return;
    }

    MD5_CTX mdContext;
    MD5_Init(&mdContext);

    unsigned char buffer[BUFFER_SIZE];
    size_t bytesRead;
    while ((bytesRead = fread(buffer, 1, sizeof(buffer), file)) != 0) {
        MD5_Update(&mdContext, buffer, bytesRead);
    }

    MD5_Final(result, &mdContext);
    fclose(file);
}

// Function to print MD5 hash
void print_md5_hash(unsigned char *hash) {
    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {
        printf("%02x", hash[i]);
    }
    printf("\n");
}

// Function to list all files in a directory and calculate their MD5 hash
void list_files_and_hash(const char *directory) {
    if (!isPathValid(directory)) {
        return;
    }

    WIN32_FIND_DATA findFileData;
    char searchPath[MAX_PATH];
    snprintf(searchPath, sizeof(searchPath), "%s\\*", directory);

    HANDLE hFind = FindFirstFile(searchPath, &findFileData);
    if (hFind == INVALID_HANDLE_VALUE) {
        printf("[!] Error accessing directory: %s\n", directory);
        logAction("[!] Directory access error.");
        return;
    }

    do {
        if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (strcmp(findFileData.cFileName, ".") != 0 && strcmp(findFileData.cFileName, "..") != 0) {
                char subDirectory[MAX_PATH];
                snprintf(subDirectory, sizeof(subDirectory), "%s\\%s", directory, findFileData.cFileName);
                list_files_and_hash(subDirectory);
            }
        } else {
            printf("File: %s\\%s\n", directory, findFileData.cFileName);
            unsigned char hash[MD5_DIGEST_LENGTH];
            char filePath[MAX_PATH];
            snprintf(filePath, sizeof(filePath), "%s\\%s", directory, findFileData.cFileName);
            calculate_md5(filePath, hash);
            printf("MD5 Hash: ");
            print_md5_hash(hash);
            logAction("[+] File analyzed successfully.");
        }
    } while (FindNextFile(hFind, &findFileData) != 0);

    FindClose(hFind);
}

// Function to list running processes securely
void list_processes() {
    printf("Listing running processes:\n");
    system("tasklist > process_list.txt");  // Save output for analysis
    printf("Process list saved to process_list.txt\n");
    logAction("[+] Process list retrieved.");
}

// Function to request explicit consent before scanning
int getUserConsent() {
    char consent[4];
    printf("‚ö†Ô∏è WARNING: Unauthorized use of this tool may violate laws.\n");
    printf("Type 'YES' to confirm you have **explicit written authorization**: ");
    scanf("%3s", consent);
    return (strcmp(consent, "YES") == 0);
}

int main() {
    // Check admin privileges
    if (!isAdmin()) {
        printf("[!] This tool requires administrative privileges. Please run as administrator.\n");
        logAction("[!] Attempted execution without admin privileges.");
        return 1;
    }

    // Require user consent
    if (!getUserConsent()) {
        printf("[!] Operation aborted. User did not provide explicit authorization.\n");
        logAction("[!] User did not provide consent.");
        return 1;
    }

    printf("Forensic Analysis Tool\n");
    printf("This program is intended for **authorized forensic analysis** use only.\n");

    // 1. List files in a directory and calculate their hashes
    char directory[MAX_PATH];
    printf("Enter the directory path to analyze (e.g., C:\\Users\\YourName\\Documents): ");
    scanf("%s", directory);

    list_files_and_hash(directory);

    // 2. List running processes to detect suspicious activities
    list_processes();

    printf("[+] Analysis complete.\n");
    logAction("[+] Forensic analysis completed.");
    return 0;
}
